<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:int="http://www.springframework.org/schema/integration"
	xmlns:file="http://www.springframework.org/schema/integration/file"
	xmlns:util="http://www.springframework.org/schema/util"
	xmlns:p="http://www.springframework.org/schema/p"
	xmlns:context="http://www.springframework.org/schema/context"
	xsi:schemaLocation="http://www.springframework.org/schema/integration
	http://www.springframework.org/schema/integration/spring-integration.xsd
	http://www.springframework.org/schema/integration/file
	http://www.springframework.org/schema/integration/file/spring-integration-file.xsd
	http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd
	http://www.springframework.org/schema/beans
	http://www.springframework.org/schema/beans/spring-beans.xsd
	http://www.springframework.org/schema/context
    http://www.springframework.org/schema/context/spring-context.xsd">

	<context:annotation-config/>

	<bean id="azureHotfolderRegStatesRemotePath" class="java.lang.String">
		<constructor-arg name="value"
			value="${azure.hotfolder.storage.container.hotfolder}/siteoneregulatorystates"/>
	</bean>

	<bean id="azureLocalRegStatesErrorRegexPatternFileListFilter"
		class="org.springframework.integration.file.filters.RegexPatternFileListFilter">
		<constructor-arg name="pattern" value="^(error_siteoneregulatoryskus|error_siteoneregulatorylicenses).*$"/>
	</bean>

	<bean id="azureHotfolderRegStatesLocalPath" class="java.lang.String">
		<constructor-arg name="value"
			value="#{azureHotfolderLocalDirectoryBase}/#{azureHotfolderRegStatesRemotePath}"/>
	</bean>

	<bean class="org.springframework.beans.factory.config.MethodInvokingFactoryBean">
		<property name="targetObject" ref="hotfolderInboundFileChannelMappings"/>
		<property name="targetMethod" value="put"/>
		<property name="arguments">
			<list>
				<bean class="java.util.regex.Pattern" factory-method="compile">
					<constructor-arg value="^(siteoneregulatoryskus|siteoneregulatorylicenses)_(\d+)(\S+)_(\d+)(\S+)\.(?i)txt"/>
				</bean>
				<ref bean="SiteOneRegStatesBatchFilesCloudHotFolderProc"/>
			</list>
		</property>
	</bean>

	<int:channel id="SiteOneRegStatesBatchFilesCloudHotFolderProc"/>

	<int:service-activator input-channel="SiteOneRegStatesBatchFilesCloudHotFolderProc" output-channel="batchSiteOneFilesHeaderInit"
		ref="SiteOneRegStatesCloudHotFolderHeaderSetupTask" method="execute">
	</int:service-activator>

	<!--  Azure Inbound File Synchronizer and Channel Adapter -->
	<bean id="SiteOneRegStatesAzureBlobInboundSynchronizer"
		class="de.hybris.platform.cloud.azure.hotfolder.remote.inbound.AzureBlobInboundSynchronizer">
		<constructor-arg name="sessionFactory" ref="azureBlobSessionFactory"/>
		<property name="remoteDirectory" value="#{azureHotfolderRegStatesRemotePath}"/>
		<property name="moveToRemoteDirectory" value="#{azureHotfolderRegStatesRemotePath}/processing"/>
		<property name="deleteRemoteFiles" value="${azure.hotfolder.storage.delete.remote.files}"/>
		<property name="preserveTimestamp" value="true"/>
		<property name="filter" ref="azureHotfolderFileFilter"/>
		<property name="comparator" ref="azureHotFolderFileComparator"/>
	</bean>

	<bean id="SiteOneRegStatesAzureBlobSynchronizingMessageSource"
		class="de.hybris.platform.cloud.azure.hotfolder.remote.inbound.AzureBlobSynchronizingMessageSource">
		<constructor-arg name="synchronizer" ref="SiteOneRegStatesAzureBlobInboundSynchronizer"/>
		<property name="autoCreateLocalDirectory" value="true"/>
		<property name="localDirectory" value="#{azureHotfolderRegStatesLocalPath}/processing/"/>
		<property name="maxFetchSize" value="${azure.hotfolder.storage.polling.fetch.batch-size}"/>
	</bean>

	<bean id="azureRegStatesChannelAdapterTaskExecutor"
		class="de.hybris.platform.cloud.commons.scheduling.HybrisAwareThreadPoolTaskExecutor">
		<property name="waitForTasksToCompleteOnShutdown" value="true"/>
		<property name="threadNamePrefix" value="AzureRegStatesIntegrationTaskExecutorThread-${tenantId}-"/>
		<property name="threadGroupName" value="AzureRegStatesIntegrationTaskExecutorThread-${tenantId}"/>
		<property name="corePoolSize" value="${azure.hotfolder.storage.polling.core-pool-size}"/>
		<property name="maxPoolSize" value="${azure.hotfolder.storage.polling.max-pool-size}"/>
		<property name="queueCapacity" value="-1"/>
		<property name="keepAliveSeconds" value="60"/>
		<property name="rejectedExecutionHandler">
			<bean class="java.util.concurrent.ThreadPoolExecutor$DiscardPolicy"/>
		</property>
		<property name="role" value="integration"/>
		<property name="autoStartup" value="false"/>
		<property name="phase" value="10"/>
		<property name="awaitTerminationSeconds" value="60"/>
	</bean>


	<bean id="SiteOneRegStatesCloudHotFolderHeaderSetupTask" class="de.hybris.platform.acceleratorservices.dataimport.batch.task.HeaderSetupTask">
		<property name="catalog" value="${cloud.hotfolder.default.mapping.header.catalog}"/>
		<property name="net" value="${cloud.hotfolder.default.mapping.header.net}" />
		<property name="storeBaseDirectory" value="#{azureHotfolderRegStatesRemotePath}/processing" />
	</bean>

	<int:inbound-channel-adapter id="SiteOneRegStatesAzureInboundChannelAdapter"
		auto-startup="false"
		role="${cloud.hotfolder.storage.services.role}"
		phase="50"
		ref="SiteOneRegStatesAzureBlobSynchronizingMessageSource"
		channel="siteOneRegStatesCloudHotFolderInboundFileHeaderEnricherChannel">
		<int:poller fixed-rate="${azure.hotfolder.storage.polling.fixed.rate}"
			task-executor="azureRegStatesChannelAdapterTaskExecutor"
			max-messages-per-poll="${azure.hotfolder.storage.polling.fetch.batch-size}">
		</int:poller>
	</int:inbound-channel-adapter>

    <int:channel id="siteOneRegStatesCloudHotFolderInboundFileHeaderEnricherChannel">
        <int:interceptors>
           <ref bean="siteOneRegStatesHotFolderRoutingChannelInterceptor"/>
        </int:interceptors>
    </int:channel>


    <bean id="siteOneRegStatesHotFolderRoutingChannelInterceptor" class="de.hybris.platform.cloud.hotfolder.interceptor.HotFolderRouterChannelInterceptor">
      <property name="successChannel" ref="SiteOneRegStatesAzureArchiveOutboundChannelAdapter"/>
      <property name="failureChannel" ref="SiteOneRegStatesAzureErrorOutboundChannelAdapter"/>
    </bean>

    <int:header-enricher id="siteOneRegStatesCloudHotFolderInboundFileNameHeaderEnricherChannel"
                input-channel="siteOneRegStatesCloudHotFolderInboundFileHeaderEnricherChannel"
                output-channel="hotfolderInboundFileChannel">
        <int:header name="#{fileNameHeaderKey}" expression="payload.getName()"/>
        <int:header name="#{fileLastModifiedHeaderKey}" expression="payload.lastModified()"/>
   </int:header-enricher>

	<!-- RegStates :: Azure Outbound Channel adapters for moving remote files into archive/error folders -->
	<bean id="SiteOneRegStatesAzureArchiveMessageHandler" parent="abstractAzureMoveMessageHandler">
		<property name="remoteDirectory" value="#{azureHotfolderRegStatesRemotePath}/archive"/>
	</bean>

	<bean id="SiteOneRegStatesAzureErrorMessageHandler" parent="abstractAzureMoveMessageHandler">
		<property name="remoteDirectory" value="#{azureHotfolderRegStatesRemotePath}/error"/>
	</bean>

	<int:outbound-channel-adapter id="SiteOneRegStatesAzureArchiveOutboundChannelAdapter"
		ref="SiteOneRegStatesAzureArchiveMessageHandler">
	</int:outbound-channel-adapter>

	<int:outbound-channel-adapter id="SiteOneRegStatesAzureErrorOutboundChannelAdapter"
		ref="SiteOneRegStatesAzureErrorMessageHandler" >
	</int:outbound-channel-adapter>


	<!--Start-->
	<file:inbound-channel-adapter id="azureLocalRegStatesErrorInboundChannelAdapter"
		directory="#{azureHotfolderRegStatesLocalPath}/error"
		filter="azureLocalRegStatesErrorHotFolderFileFilter">
		<int:poller fixed-rate="10000"/>
	</file:inbound-channel-adapter>

	<bean id="azureLocalRegStatesErrorHotFolderFileFilter"
		class="de.hybris.platform.cloud.commons.spring.integration.file.filters.ChainFileListFilter">
		<constructor-arg name="fileFilters" ref="azureLocalRegStatesErrorFolderFileListFilter"/>
	</bean>

	<util:list id="azureLocalRegStatesErrorFolderFileListFilter">
		<ref bean="azureLocalRegStatesErrorRegexPatternFileListFilter"/>
		<ref bean="azureFileSystemPersistentAcceptOnceListFilter"/>
	</util:list>

	<bean id="azureFileSystemPersistentAcceptOnceListFilter" class="org.springframework.integration.file.filters.FileSystemPersistentAcceptOnceFileListFilter">
		<constructor-arg name="store" ref="hotfolderMetadataStore"/>
		<constructor-arg name="prefix" value="${azure.hotfolder.storage.metadatastore.prefix}"/>
	</bean>

	<int:outbound-channel-adapter id="azureLocalRegStatesErrorOutboundChannelAdapter"
		channel="azureLocalRegStatesErrorInboundChannelAdapter" ref="azureRegStatesBlobMessageHandler"/>

	<bean id="azureRegStatesBlobMessageHandler" class="de.hybris.platform.cloud.azure.hotfolder.remote.outbound.AzureBlobMessageHandler">
		<constructor-arg ref="azureBlobSessionFactory"/>
		<property name="remoteDirectory" ref="azureRegStatesHotfolderErrorRemotePath"/>
		<property name="fileNameGenerator" ref="azureTimestampFileNameGenerator"/>
		<property name="deleteSourceFiles" value="true"/>
	</bean>

	<bean id="azureRegStatesHotfolderErrorRemotePath" class="java.lang.String">
		<constructor-arg name="value"
			value="#{azureHotfolderRegStatesRemotePath}/error"/>
	</bean>

	<bean id="batchSiteOneRegulatorySkusConverterMapping"
		class="de.hybris.platform.acceleratorservices.dataimport.batch.converter.mapping.impl.DefaultConverterMapping"
		p:mapping="siteoneregulatoryskus"
		p:converter-ref="batchSiteOneRegulatorySkusConverter" />
	<bean id="batchSiteOneRegulatorySkusConverter"
		class="de.hybris.platform.acceleratorservices.dataimport.batch.converter.impl.DefaultImpexConverter">
		<property name="header">
			<value>
				INSERT_UPDATE RegulatoryStates;sku[unique=true];state(isoCode)[unique=true][cellDecorator=com.siteone.core.batch.decorator.RegionCellDecorator];expirationDate[dateformat='yyyy-MM-dd''T''HH:mm:ss''Z'''];isRup[default=false];
			</value>
		</property>
		<property name="impexRow">
			<value>;{+0};{4}-{1};{2};{3};</value>
		</property>
	</bean>

	<bean id="batchSiteOneRegulatoryLicenseConverterMapping"
		class="de.hybris.platform.acceleratorservices.dataimport.batch.converter.mapping.impl.DefaultConverterMapping"
		p:mapping="siteoneregulatorylicenses"
		p:converter-ref="batchSiteOneRegulatoryLicenseConverter" />
	<bean id="batchSiteOneRegulatoryLicenseConverter"
		class="de.hybris.platform.acceleratorservices.dataimport.batch.converter.impl.DefaultImpexConverter">
		<property name="header">
			<value>
				UPDATE PointOfService;storeId[unique=true];division(uid)[unique=true][cellDecorator=com.siteone.core.batch.decorator.CountryDivisionCellDecorator];licenseEndDate[dateformat='yyyy-MM-dd''T''HH:mm:ss''Z'''];
			</value>
		</property>
		<property name="impexRow">
			<value>;{+0};{2};{1}</value>
		</property>
	</bean>

</beans>